# Java 基础题

## 1、Java语言的三大特性

1. **封装**：首先，属性可用来描述同一类事物的特征，方法可描述一类事物可做的操作。封装就是把属于同一类事物的共性（包括属性与方法）归到一个类中，以方便使用。
   1. 概念：封装也称为信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其核成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留些对外接口使之与外部发生联系。系统的其他部分只有通过包裹在数据外面的被授权的操作来与这个抽象数据类型交流与交互。也就是说，用户无需知道对象内部方法的实现细节，但可以根据对象提供的外部接口（对象名和参数）访问该对象。
   2. 好处：（1）实现了专业的分工。将能实现某一特定功能的代码封装成一个独立的实体后，各程序员可以在需要的时候调用，从而实现了专业的分工。（2）隐藏信息，实现细节。通过控制访问权限可以将可以将不想让客户端程序员看到的信息隐藏起来，如某客户的银行的密码需要保密，只能对该客户开发权限。

2. **继承**：就是个性对共性的属性与方法的接受，并加入个性特有的属性与方法。

   1. 概念：一个类继承另一个类，则称继承的类为子类，被继承的类为父类。

   2. 目的：实现代码的复瑶挨懊盎饱苯步。

   3. 理解：子类与父类的关系并不是日常生活中的父子关系，子类与父类而是一种特殊化与一般化的关系，是is-a的关系，子类是父类更加详细的分类。如 class dog extends animal，就可以理解为 dog is aanimal 注意设计继承的时候，若要让某个类能继承，父类需适当开放访问权限，遵循里氏代换原则，即向修改关闭对扩展开放，也就是开-闭原则。
   
   4. 结果：继承后子类自动拥有了父类的属性和方法，但特别注意的是，父类的私有属性和构造方法并不能被继承。
   
      另外子类可以写自己特有的属性和方法，目的是实现功能的扩展，子类也可以复写父类的方法即方法的重写。

3. **多态**：多态的概念发展出来，是以封装和继承为基础的。多态就是在抽象的层面上实施一个统一的行为，到个体（具体）的层面上时，这个统一的行为会因为个体（具体）的形态特征而实施自己的特征行为。（针对一个抽象的事，对于内部个体又能找到其自身的行为去执行）

   1. 概念：相同的事物，调用其相同的方法，参数也相同时，但表现的行为却不同。

   2. 理解：子类以父类的身份出现，但做事情时还是以自己的方法实现。子类以父类的身份出现需要向上转型（upcast），其中向上转型是由 JVM 自动实现的，是安全的，但向下转型（downcast）是不安全的，需要强制转换。子类以弗雷德身份出现时自己特有的属性和方法将不能使用。

      

## 2、Java语言主要特性

1. **Java语言是易学的**。Java 语言的语法与 C 语言和 C++ 语言很接近，使得大多数程序员很容易学习和使用 Java。

2. **Java语言是强制面向对象的**。Java 语言提供类、接口和继承等原语，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）

3. **Java语言是分布式的**。Java 语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口 （java net），它提供了用于网络应用编程的类库，句括 URL、URLConnection、Socket、ServerSocket 等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。

4. **Java语言是健壮的**。Java 的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。

5. **Java语言是安全的**。Java 通常被用在网络环境中，为此，Java 提供了一个安全机制以防恶意代码的攻击。如: 安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查。

6. **Java语言是体系结构中立的**。Java 程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节码格式（后缀为class的文件) ，然后可以在实现这个 Java 平台的任何系统中运行。

7. **Java语言是解释型的**。如前所述，Java 程序在Java平台上被编译为字节码格式，然后可以在实现这个 Java 平台的任何系统的解释器中运行。 (一次编译，到处运行）

8. **Java是性能略高的**。与那些解释型的高级脚本语言相比，Java的性能还是较优的。

9. **Java语言是原生支持多线程的**。在 Java 语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。

  

## 3、JDK 和 JRE 有什么区别

- JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。

- JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需的环境。

具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源代码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果需要运行 Java 程序，只需要安装 JRE 就行了，如果你需要编写 Java 程序，需要安装 JDK。



## 4、Java基本数据类型及其封装类

| 基本类型 | 大小（字节） | 默认值       | 封装类    |
| -------- | ------------ | ------------ | --------- |
| byte     | 1            | (byte)0      | Byte      |
| short    | 2            | (short)0     | Short     |
| int      | 4            | 0            | Integer   |
| long     | 8            | 0L           | Long      |
| float    | 4            | 0.0f         | Float     |
| double   | 8            | 0.0d         | Double    |
| boolean  | -            | false        | Boolean   |
| char     | 2            | \u0000(null) | Character |

Tips：boolean 类型占了单独使用是4个字节，在数组中又是1个字节基本类型所占的存储空间是不变的。这种不变性也是Java具有可移植性的原因之一基本类型放在栈中，直接存储值。

所有数值类型都有正负号，没有无符号的数值类型。

为什么需要封装类？因为泛型类包括预定义的集合，使用的参数都是对象类型，无法直接使用基本数据类型，所以Java又提供了这些基本类型的封装类。

基本类型和对应的封装类由于本质的不同。具有一些区别：

1. 基本类型只能按值传递，而封装类按引用传递。
2. 基本类型会在栈中创建，而对于对象类型，对象在堆中创建，对象的引用在栈中创建，基本类型由于在栈中，效率会比较高，但是可能存在内存泄漏的问题。



## 5、如果 main 方法被声明为 private 会怎样？

能正常编译，但运行的时候会提示“main 方法不是 public 的”。在 idea 中如果不用 public 修饰，则会自动去掉可运行的按钮。



## 6.说明一下public static void main(String args) 这段声明里每个关键字的作用

public：main 方法是 Java 程序运行时调用的第一个方法，因此它必须对 Java 环境可见。所以可见性设置为 pulic。

static：Java 平台调用这个方法时不会创建这个类的一个实例，因此这个方法必须声明为 static。

void：main方法没有返回值。

String 是命令行传进参数的类型，args 是指命令行传进的字符串数组。



## 7、== 与 equals 的区别

== 比较两个对象在内存里是不是同一个对象，就是所在内存里的存储位置一致。两个 String 对象存储的值是一样的，但有可能在内存里存储在不同的地方。

== 比较的是引用而 equals 方法比较的是内容，`public boolean equals(Object obj)` 这个方法是由 Object 对象提供的，可以由子类进行重写。默认的实现只有当对象和自身进行比较时才会返回 true，这个时候和 == 是等价的。String，BitSet，Data，和 File 都对 equal 方法进行了重写，对两个 String 对象而言，值相等意味着他们包含着同样的字符串序列。对于基本类型的包装类来说，值相等意味着对应的基本类型的值一样。

```java
public class EqualsTest {
		public static void main(String[] args) {
    		String s1 = “abc”;
 				String s2 = s1;
 				String s5 = “abc”;
 				String s3 = new String(”abc”);
 				String s4 = new String(”abc”);
 				System.out.println(”== comparison : ” + (s1 == s5));
 				System.out.println(”== comparison : ” + (s1 == s2));
 				System.out.println(”Using equals method : ” + s1.equals(s2));
 				System.out.println(”== comparison : ” + s3 == s4);
 				System.out.println(”Using equals method : ” + s3.equals(s4));
 		}
}
```

